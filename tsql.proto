// This file provides the TSQL AST. The root of the AST is the `Statement`
// message defined at the bottom.

syntax = "proto2";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

import "tsz.proto";

package tsql;

// A literal constant such as 42, 3.14, or "hello".
message ConstantExpression {
  oneof value {
    bool bool_value = 1;
    int64 int64_value = 2;
    double double_value = 3;
    string string_value = 4;
  }
}

// The `VAL` token referring to the metric value.
message ValueExpression {}

// The `FIELDS` token referring to the field map (including both target fields and metric fields).
message FieldMapExpression {}

// A tuple of two or more sub-expressions.
message TupleExpression {
  repeated Expression component = 1;
}

// A named tuple of two or more sub-expressions.
message NamedTupleExpression {
  message NamedComponent {
    optional string name = 1;
    optional Expression expression = 2;
  }
  repeated NamedComponent component = 1;
}

message SubscriptExpression {
  optional Expression operand = 1;
  optional Expression index = 2;
}

message NegExpression {
  optional Expression operand = 1;
}

message AddExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message SubExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message MulExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message DivExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message IntDivExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message ModExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message PowExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message CeilExpression {
  optional Expression operand = 1;
}

message FloorExpression {
  optional Expression operand = 1;
}

message RoundExpression {
  optional Expression operand = 1;
}

message AbsExpression {
  optional Expression operand = 1;
}

message SqrtExpression {
  optional Expression operand = 1;
}

message LogExpression {
  optional Expression operand = 1;
}

message ExponentialExpression {
  optional Expression operand = 1;
}

message AndExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message OrExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message NotExpression {
  optional Expression operand = 1;
}

message XorExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message OrElseExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message HasValueExpression {
  optional Expression operand = 1;
}

message CondExpression {
  optional Expression condition = 1;
  optional Expression then_branch = 2;
  optional Expression else_branch = 3;
}

message LtExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message GtExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message EqExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message NeExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message LeExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message GeExpression {
  optional Expression lhs = 1;
  optional Expression rhs = 2;
}

message ConcatExpression {
  repeated Expression operand = 1;
}

message RegexpMatchesValueExpression {
  optional Expression pattern = 1;
  optional Expression operand = 2;
  optional Expression full_match = 3;
}

message RegexpReplaceValueExpression {
  optional Expression pattern = 1;
  optional Expression rewrite = 2;
  optional Expression operand = 3;
  optional Expression global = 4;
}

message RegexpExtractTupleExpression {
  optional Expression pattern = 1;
  optional Expression operand = 2;
  optional Expression full_match = 3;
}

message RegexpExtractValueExpression {
  optional Expression pattern = 1;
  optional Expression rewrite = 2;
  optional Expression operand = 3;
  optional Expression default_value = 4;
}

message AsciiToUpperExpression {
  optional Expression operand = 1;
}

message AsciiToLowerExpression {
  optional Expression operand = 1;
}

message StringLengthExpression {
  optional Expression operand = 1;
}

message TimestampMicrosExpression {}

message ResetTimestampMicrosExpression {}

message NextOlderValueExpression {}

message NextOlderTimestampMicrosExpression {}

message NextOlderResetTimestampMicrosExpression {}

// A value expression within a TSQL query.
message Expression {
  oneof value {
    ConstantExpression constant_expression = 1;
    ValueExpression value_expression = 2;
    FieldMapExpression field_map_expression = 3;
    TupleExpression tuple_expression = 4;
    NamedTupleExpression named_tuple_expression = 5;
    SubscriptExpression subscript_expression = 6;
    NegExpression neg_expression = 7;
    AddExpression add_expression = 8;
    SubExpression sub_expression = 9;
    MulExpression mul_expression = 10;
    DivExpression div_expression = 11;
    IntDivExpression int_div_expression = 12;
    ModExpression mod_expression = 13;
    PowExpression pow_expression = 14;
    CeilExpression ceil_expression = 15;
    FloorExpression floor_expression = 16;
    RoundExpression round_expression = 17;
    AbsExpression abs_expression = 18;
    SqrtExpression sqrt_expression = 19;
    LogExpression log_expression = 20;
    ExponentialExpression exponential_expression = 21;
    AndExpression and_expression = 22;
    OrExpression or_expression = 23;
    NotExpression not_expression = 24;
    XorExpression xor_expression = 25;
    OrElseExpression or_else_expression = 26;
    HasValueExpression has_value_expression = 27;
    CondExpression cond_expression = 28;
    LtExpression lt_expression = 29;
    GtExpression gt_expression = 30;
    EqExpression eq_expression = 31;
    NeExpression ne_expression = 32;
    LeExpression le_expression = 33;
    GeExpression ge_expression = 34;
    ConcatExpression concat_expression = 35;
    RegexpMatchesValueExpression regexp_matches_value_expression = 36;
    RegexpReplaceValueExpression regexp_replace_value_expression = 37;
    RegexpExtractTupleExpression regexp_extract_tuple_expression = 38;
    RegexpExtractValueExpression regexp_extract_value_expression = 39;
    AsciiToUpperExpression ascii_to_upper_expression = 40;
    AsciiToLowerExpression ascii_to_lower_expression = 41;
    StringLengthExpression string_length_expression = 42;
    TimestampMicrosExpression timestamp_micros_expression = 43;
    ResetTimestampMicrosExpression reset_timestamp_micros_expression = 44;
    NextOlderValueExpression next_older_value_expression = 45;
    NextOlderTimestampMicrosExpression next_older_timestamp_micros_expression = 46;
    NextOlderResetTimestampMicrosExpression next_older_reset_timestamp_micros_expression = 47;
    // TODO
  }
}

message SumReducer {
  optional bool output_on_empty_input = 1 [default = false];
}

message CountReducer {
  optional bool output_on_empty_input = 1 [default = false];
}

message ValueCountReducer {
  optional bool output_on_empty_input = 1 [default = false];
}

message MeanReducer {}

message MinReducer {}

message MaxReducer {}

message RangeReducer {}

message VarianceReducer {}

message StdDevReducer {}

message CovarianceReducer {}

message SingletonReducer {}

message MakeDistributionReducer {
  optional bool output_on_empty_input = 1 [default = false];
  optional double width = 2;
  optional double growth_factor = 3;
  optional double scale_factor = 4;
  optional uint32 num_finite_buckets = 5;
}

message MakeWeightedDistributionReducer {
  optional bool output_on_empty_input = 1 [default = false];
  optional double width = 2;
  optional double growth_factor = 3;
  optional double scale_factor = 4;
  optional uint32 num_finite_buckets = 5;
}

message FractionTrueReducer {}

message CountTrueReducer {
  optional bool output_on_empty_input = 1 [default = false];
}

message PickAnyReducer {}

message PickByMaxReducer {
  optional string field_name = 1;
}

message MinMeanMaxReducer {}

message ElementwiseReducer {
  message Component {
    optional string input_name = 1;
    optional string output_name = 2;
    optional ReducerFunction reducer = 3;
  }
  repeated Component component = 1;
}

message ReducerFunction {
  oneof reducer {
    SumReducer sum_reducer = 1;
    CountReducer count_reducer = 2;
    ValueCountReducer value_count_reducer = 3;
    MeanReducer mean_reducer = 4;
    MinReducer min_reducer = 5;
    MaxReducer max_reducer = 6;
    RangeReducer range_reducer = 7;
    VarianceReducer variance_reducer = 8;
    StdDevReducer std_dev_reducer = 9;
    CovarianceReducer covariance_reducer = 10;
    SingletonReducer singleton_reducer = 11;
    MakeDistributionReducer make_distribution_reducer = 12;
    MakeWeightedDistributionReducer make_weighted_distribution_reducer = 13;
    FractionTrueReducer fraction_true_reducer = 14;
    CountTrueReducer count_true_reducer = 15;
    PickAnyReducer pick_any_reducer = 16;
    PickByMaxReducer pick_by_max_reducer = 17;
    MinMeanMaxReducer min_mean_max_reducer = 18;
    ElementwiseReducer elementwise_reducer = 19;
  }
}

message FilterNode {
  optional uint32 input_node_index = 1;
  optional Expression operation = 2;
}

message UnionNode {
  repeated uint32 input_node_index = 1;
  optional ReducerFunction reducer_function = 2;
}

message MapStreamIdNode {
  optional uint32 input_node_index = 1;
  optional string out_target_schema_name = 2;
  map<string, Expression> out_field_map = 3;
  optional ReducerFunction reducer_function = 4;
  optional bool drop_metric_fields = 5 [default = false];
  optional bool drop_target_fields = 6 [default = false];
}

message PickTopPointsNode {
  optional uint32 input_node_index = 1;
  optional uint64 num_to_keep = 2;
  repeated string group_by_fields = 3;
  optional bool invert_group_by = 4 [default = false];
  optional bool reverse_sort = 5 [default = false];
}

message PickTopStreamsNode {
  optional uint32 input_node_index = 1;
  optional uint64 num_to_keep = 2;
  optional google.protobuf.Duration window = 3;
  repeated string group_by_fields = 4;
  optional ReducerFunction reducer_function = 5;
  optional Expression operation = 6;
  optional google.protobuf.Duration time_offset = 7;
  optional bool invert_group_by = 8 [default = false];
  optional bool reverse_sort = 9 [default = false];
}

message JoinWithLiteralTableNode {
  optional uint32 input_node_index = 1;

  optional string target_schema_name = 2;
  repeated string field_name = 3;

  message TableEntry {
    repeated Expression field_value = 1;
    optional Expression value = 2;
  }

  repeated TableEntry table_entry = 4;

  optional Expression input_default = 5;
  optional Expression literal_default = 6;

  optional Expression input_name = 7;
  optional Expression literal_name = 8;
}

message JoinNode {
  optional string left_name = 1;
  optional string right_name = 2;
  optional Expression left_default = 3;
  optional Expression right_default = 4;
  optional uint32 left_node_index = 5;
  optional uint32 right_node_index = 6;
}

message TimeShiftNode {
  optional uint32 input_node_index = 1;
  optional google.protobuf.Duration shift_duration = 2;
}

message PointNode {
  optional uint32 input_node_index = 1;
  optional Expression expression = 2;
}

message GroupByNode {
  optional uint32 input_node_index = 1;
  repeated string fields = 2;
  optional ReducerFunction reducer = 3;
  optional bool invert = 4 [default = false];
}

message WindowNode {
  optional uint32 input_node_index = 1;

  message Align {
    optional google.protobuf.Duration max_interpolation_gap = 1;
    optional bool linear = 2 [default = false];
    optional google.protobuf.Duration max_extrapolation_gap = 3;
  }

  message NextYounger {
    optional google.protobuf.Duration max_interpolation_gap = 1;
    optional google.protobuf.Duration max_extrapolation_gap = 2;
  }

  message Rate {
    optional google.protobuf.Duration time_delta = 1;
    optional google.protobuf.Duration max_extrapolation_gap = 2;
  }

  message Delta {
    optional google.protobuf.Duration time_delta = 1;
    optional google.protobuf.Duration max_extrapolation_gap = 2;
  }

  message Reduce {
    optional google.protobuf.Duration window = 1;
    optional ReducerFunction reducer = 2;
  }

  oneof window_function {
    Align align = 2;
    NextYounger next_younger = 3;
    Rate rate = 4;
    Delta delta = 5;
    Reduce reduce = 6;
  }

  // This field is required iff this is *not* the last `Window` stage of its branch in the query.
  // The output period of the last `Window` stage must be specified in the outer `QueryStatement`
  // message rather than here.
  optional google.protobuf.Duration output_period = 7;
}

// Refers to the stream table of a raw metric.
message RawStreamTable {
  optional string target_schema = 1;
  optional string metric_name = 2;
}

// Refers to the stream table of a precomputation.
message PrecomputedStreamTable {
  optional string group_id = 1;
  optional string module_name = 2;
  optional string precomputation_name = 3;
  map<string, StreamTable> precomputation_parameters = 4;
}

message AbstractStreamTable {
  optional string parameter_name = 1;
}

message StreamTable {
  oneof stream_table {
    RawStreamTable raw_stream_table = 1;
    PrecomputedStreamTable precomputed_stream_table = 2;
    AbstractStreamTable abstract_stream_table = 3;
  }
}

// Expresses a constraint on a target or metric field.
message FieldPredicate {
  // Name of the field this predicate applies to.
  optional string field_name = 1;

  // When this flag is set the constraint is satisfied iff the field does NOT satisfy the predicate.
  optional bool invert = 2 [default = false];

  // Matches a field with any value, as long as there is a value. Unset fields do not match.
  message AllMatch {}

  // Matches a field whose value is compared with the given one.
  message ValueMatch {
    enum Op {
      FIELD_PREDICATE_OP_EQ = 0;
      FIELD_PREDICATE_OP_NE = 1;
      FIELD_PREDICATE_OP_LT = 2;
      FIELD_PREDICATE_OP_LE = 3;
      FIELD_PREDICATE_OP_GT = 4;
      FIELD_PREDICATE_OP_GE = 5;
    }

    // The comparison operation.
    optional Op comparison = 1 [default = FIELD_PREDICATE_OP_EQ];

    // The value to compare against.
    optional tsz.FieldValue value = 2;
  }

  // The field is string-typed and must match the given regular expression pattern. The pattern is
  // not anchored by default, so if a full match is required you need to surround it in ^ and $.
  message RegexpMatch {
    optional string pattern = 1;
  }

  // How to match the value of the field.
  oneof constraint {
    AllMatch all_match = 3;
    ValueMatch value_match = 4;
    RegexpMatch regexp_match = 5;
  }
}

// A set of field predicates.
//
// Note that there may be more than one predicate for the same field, in which case they all apply
// (as if they were ANDed). If the predicates associated to a given field are mutually incompatible
// then no field set will ever match this field predicate set.
message FieldPredicates {
  repeated FieldPredicate field_predicate = 1;
}

message FetchNode {
  // The stream table to fetch.
  optional StreamTable stream_table = 1;

  // Both target fields and metric fields may be specified in these predicates. Metric field names
  // must be prefixed with `metric:`.
  optional FieldPredicates field_predicates = 2;
}

// A node made up of two or more sub-nodes.
//
// For example, in the following expression:
//
//   (
//    Fetch(Raw('FooSchema', '/foo/numerator')),
//    Fetch(Raw('FooSchema', '/foo/denominator')))
//   | Window(Rate('1m'))
//   | GroupBy([])
//   | Join()
//   | Point(Div())
//
// the first stage is a tuple node containing two `Fetch` nodes.
message TupleNode {
  repeated uint32 node_index = 1;
}

// A node of the abstract syntax tree.
message Node {
  oneof node {
    TupleNode tuple_node = 1;
    FetchNode fetch_node = 2;
    WindowNode window_node = 3;
    GroupByNode group_by_node = 4;
    PointNode point_node = 5;
    TimeShiftNode time_shift_node = 6;
    JoinNode join_node = 7;
    JoinWithLiteralTableNode join_with_literal_table_node = 8;
    PickTopStreamsNode pick_top_streams_node = 9;
    PickTopPointsNode pick_top_points_node = 10;
    MapStreamIdNode map_stream_id_node = 11;
    UnionNode union_node = 12;
    FilterNode filter_node = 13;
  }
}

// Queries a TSQL expression.
message QueryStatement {
  // node[0] is the root of the expression. Other nodes are referred to by their indexes in this
  // array.
  //
  // Note that nodes refer to their input(s), so the root node[0] is actually the *last* node of the
  // expression, not the first. For example, in the following expression:
  //
  //   Fetch(Raw(...))
  //   | Window(Align('1m'))
  //   | Point(VAL * 2)
  //   | GroupBy(['foo', 'bar'])
  //
  // the root is the `GroupBy` node, not the `Fetch` node.
  repeated Node node = 1;

  // If `time` is provided a single point interpolated at that timestamp will be returned for each
  // output stream, while if `interval` is provided all points in that time range will be returned.
  oneof time_or_interval {
    google.protobuf.Timestamp time = 2;
    google.protobuf.Duration interval = 3;
  };

  optional google.protobuf.Duration output_period = 4;
}

// A general TSQL statement. This is the root of the TSQL AST.
message Statement {
  oneof statement {
    QueryStatement query = 1;
    // TODO
  };
}
